# Job groups design doc
 

## Problem

 

Many jobs submitted to cook are actually part of a logical group, for example, a spark driver submits 10 spark executors. 

The driver is aware that the 10 executors are a group and manages them as so, but cook has no idea. 

Cook is unable to offer the executors options about how they are placed on hosts because it doesn't know they are related.

 

In another scenario, a single batch of map reduce jobs must be managed by a separate process if it wants to monitor the batch

for stragglers or fail the batch if one task fails. 

Additionally, the process must keep track of the whole batch and keep the data historically for reporting and debugging.

 

## High level idea

 

Add a new field on jobs to define a uuid for a group the job belongs to. 

The client can then set additional metadata on the group to inform cook on options for the group.

 

For example, job groups could allow for group:

 

1. Querying

2. Reporting

3. Failure semantics (if one fails, all fail)

4. Host placement (all on same host, unique hosts, balanced across hosts)

5. Straggler detection and response

 

## Changes to the api

 

Add a new endpoint to create a group and manage group prefences such has host placement preferences, failure semantics and straggler detection.

 

Add another field on job's for a group uuid, generated by the client. 

Any jobs that share the group uuid will be treated as in the same group (as long as they are owned by the same user, otherwise, an error should be thrown).

 

Add a new endpoint to query for the jobs in a group.

 

###Open question: Should jobs be able to set a group id without explicitly creating it?

####Choice: Yes

This makes it easier for clients to group jobs when they don't intend to set any preferences about the group. 

It also makes the failure cases (create a group, then client fails) a little more managable. 

However, this means we either need to allow group preferences to be mutable since a client could first submit jobs then change preferences

or assert that the only way to have a group with non-default preferences is to create it first.

####Choice: No

This makes the protocol a bit simplier to understand (if you want to use groups, explicitly create them first) but adds a step to the submission process

and is more heavy weight for clients that just want to use the defaults and use groups for querying.

 

###Open question: Should groups be part of a single batch submission (to /rawscheduler)?

####Choice: Yes

This reduces the number of requests a client needs to make (and reduces the failure surface) and allows for a simplier submission protocol in the case that a group of jobs spans only one submission

####Choice: No

The explicit handshake of creating a group first makes it the multiple submission batches case simplier.

 

## Changes to the database

 

### Open question: Have a `group` entity which has a list of `job` entities or have the `job` entity have a ref to a group

#### Choice: `group` entity with list of `job`s 

This allows for a job to be a member of multiple groups (a hierachy of jobs) as multiple groups can contain the same job.

This complicates some of the other preference logic.

#### Choice: `job` entity has `group` ref

This is more intuitive and makes handling of preference logic simplier. Adding multiple groups will likely require more code changes.

